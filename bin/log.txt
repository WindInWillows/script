Decl[int] RAND_SEED=0
PushStack
Decl[string] x=def
switch(VAR[0,0](x))
RecoverStack
f1[0]
Decl[struct list_node] _LIST_NULL_CONSTANT_
inter.Set(aVAR[0,1](_LIST_NULL_CONSTANT_),aVAR[0,1](_LIST_NULL_CONSTANT_).prev)
PushStack
Decl[int] x=time[]
println[Random seed: + inter.StrConversion(VAR[0,0](x))]
srand[VAR[0,0](x)]
RecoverStack
print[------------------
]
print[+   Test Begin   +
]
print[------------------
]
println[Test for classic code]
println[hello world!]
println[Test for build-in variable]
println[This code is in file  + ../testcase/test.xs +  at  + inter.StrConversion(98)]
println[Compiler version is  + inter.StrConversion(102 / 100) + . + inter.StrConversion(102 % 100)]
println[Test for basic painting]
setBrushColor[25, 25, 255]
PushStack
Decl[real] x
Decl[real] y
Decl[int] a=20
Decl[int] b=20
Decl[real] x_m
Decl[real] y_m
PushStack
for(Decl[real] t=- 10.0
;inter.RealRel;inter.RealSet(VAR[0,0](t),0.01)
){
inter.Set(VAR[1,0](x),inter.IntRealConversion(20) * VAR[0,0](t) + inter.IntRealConversion(1) / VAR[0,0](t) / inter.IntRealConversion(2))
inter.Set(VAR[1,4](x_m),- VAR[1,0](x))
inter.RealSet(VAR[1,0](x),inter.IntRealConversion(300))
inter.RealSet(VAR[1,4](x_m),inter.IntRealConversion(300))
inter.Set(VAR[1,1](y),inter.IntRealConversion(20) * VAR[0,0](t) - inter.IntRealConversion(1) / VAR[0,0](t) / inter.IntRealConversion(2))
inter.Set(VAR[1,1](y),- VAR[1,1](y))
inter.Set(VAR[1,5](y_m),- VAR[1,1](y))
inter.RealSet(VAR[1,1](y),inter.IntRealConversion(240))
inter.RealSet(VAR[1,5](y_m),inter.IntRealConversion(240))
if(inter.And){
addPoint[inter.RealIntConversion(VAR[1,0](x)), inter.RealIntConversion(VAR[1,1](y))]
addPoint[inter.RealIntConversion(VAR[1,0](x)), inter.RealIntConversion(VAR[1,5](y_m))]
addPoint[inter.RealIntConversion(VAR[1,4](x_m)), inter.RealIntConversion(VAR[1,1](y))]
addPoint[inter.RealIntConversion(VAR[1,4](x_m)), inter.RealIntConversion(VAR[1,5](y_m))]

}

}
RecoverStack
RecoverStack
setBrushColor[255, 0, 0]
PushStack
for(Decl[real] y=1.5
;inter.RealRel;inter.RealSet(VAR[0,0](y),0.01)
){
PushStack
for(Decl[real] x=- 1.5
;inter.RealRel;inter.RealSet(VAR[0,0](x),0.005)
){
PushStack
Decl[real] a=VAR[1,0](x) * VAR[1,0](x) + VAR[2,0](y) * VAR[2,0](y) - inter.IntRealConversion(1)
if(inter.RealRel){
addPoint[inter.RealIntConversion(VAR[1,0](x) * inter.IntRealConversion(100) + inter.IntRealConversion(300) - inter.IntRealConversion(100)), inter.RealIntConversion(- VAR[2,0](y) * inter.IntRealConversion(100) + inter.IntRealConversion(240) - inter.IntRealConversion(80))]

}
RecoverStack

}
RecoverStack

}
RecoverStack
setBrushColor[0, 255, 0]
PushStack
Decl[real] r=100.0
PushStack
for(Decl[int] y=inter.RealIntConversion(VAR[1,0](r))
;inter.RealRel;inter.IntSet(VAR[0,0](y),1)
){
PushStack
for(Decl[int] x=inter.RealIntConversion(- VAR[2,0](r))
;inter.IntRel;inter.IntSet(VAR[0,0](x),1)
){
PushStack
Decl[int] a=VAR[1,0](x) * VAR[1,0](x) + VAR[2,0](y) * VAR[2,0](y)
if(inter.RealRel){
addPoint[VAR[1,0](x) + 300 + 100, - VAR[2,0](y) + 240 + 100]

}
RecoverStack

}
RecoverStack

}
RecoverStack
setBrushColor[0, 0, 0]
addLine[0, 240, 600, 240]
addLine[300, 0, 300, 480]
openPad[600, 480]
paint[]
getchar[]
getchar[]
closePad[]
RecoverStack
PushStack
Decl[struct list] a=create_list[]
Decl[struct list] b=create_list[]
Decl[int] size=7
PushStack
for(Decl[int] i=0
;inter.IntRel;++ VAR[0,0](i)
){
push_back[VAR[1,0](a), rand[] % 31]
push_back[VAR[1,1](b), rand[] % 31]

}
RecoverStack
println[Test for struct]
print[Generating Test Data
]
print[a=]
println[list_toString[VAR[0,0](a)]]
print[b=]
println[list_toString[VAR[0,1](b)]]
print[a U b=]
println[list_toString[union_list[VAR[0,0](a), VAR[0,1](b)]]]
print[SORT
]
print[sort(a)=
]
println[list_toString[qlsort[VAR[0,0](a), 0]]]
RecoverStack
println[Test for member functions]
srand[time[]]
PushStack
Decl[struct CORD] o
inter.Set(VAR[0,0](o).x,inter.IntRealConversion(rand[] % 25))
inter.Set(VAR[0,0](o).y,inter.IntRealConversion(rand[] % 25))
println[toString[VAR[0,0](o)]]
init[VAR[0,0](o), inter.IntRealConversion(rand[] % 25), inter.IntRealConversion(rand[] % 25)]
println[toString[VAR[0,0](o)]]
RecoverStack
println[Test for dynamic array sizeof]
println[int[244] arr;]
println[arr = new<int>(25);]
println[println(sizeof arr);]
println[println(sizeof new<int>(25));]
PushStack
Decl[int[]] arr
inter.Set(VAR[0,0](arr),new []int[])
println[inter.StrConversion(sizeof VAR[0,0](arr))]
println[inter.StrConversion(sizeof new []int[])]
RecoverStack
println[Test for dynamic array]
PushStack
Decl[int[]] tmp
Decl[int[][]] x
Decl[int[][]] b
inter.Set(VAR[0,1](x),new []int[][])
inter.Set(VAR[0,2](b),VAR[0,1](x))
println[b[2] =  + inter.StrConversion(VAR[0,2]([]))]
println[b[1] =  + inter.StrConversion(VAR[0,2]([]))]
RecoverStack
Decl[int[][]] a
Decl[int] buffer=- 1
inter.Set(VAR[0,2]([]),212)
Decl[int] c=VAR[0,2]([])
print[-----------------
]
print[+Test For Input +
]
print[-----------------
]
println[Sample:1+2[ENTER]]
PushStack
Decl[int] i=readint[]
Decl[int] t=bufgetchar[]
Decl[int] j=readint[]
print[ + inter.StrConversion(VAR[0,0](i)) +   + inter.StrConversion(inter.IntCharConversion(VAR[0,1](t))) +   + inter.StrConversion(VAR[0,2](j)) + =]
if(inter.IntRel ){
print[inter.StrConversion(VAR[0,0](i) + VAR[0,2](j))]
}else {
if(inter.IntRel ){
print[inter.StrConversion(VAR[0,0](i) - VAR[0,2](j))]
}else {
if(inter.IntRel ){
print[inter.StrConversion(VAR[0,0](i) * VAR[0,2](j))]
}else {
if(inter.IntRel ){
print[inter.StrConversion(VAR[0,0](i) / VAR[0,2](j))]
}else {
print[error]
}
}
}
}
print[
]
getchar[]
getchar[]
RecoverStack
Decl[struct tree_node] null
inter.Set(aVAR[0,5](null),aVAR[0,5](null).left)
srand[time[]]
PushStack
Decl[struct tree_node] tree
inter.Set(VAR[0,0](tree),randomly_create_tree[])
prettily_show_tree[VAR[0,0](tree), 0]
RecoverStack
PushStack
Decl[int[]] arr
Decl[int] i=0
Decl[int] seed=time[]
print[seed =  + inter.StrConversion(VAR[0,2](seed)) + 
]
srand[VAR[0,2](seed)]
Decl[int] len=rand[] % 200
for(inter.Set(VAR[0,1](i),0)
;inter.IntRel;++ VAR[0,1](i)
){
inter.Set(VAR[0,0]([]),rand[] % VAR[0,3](len))

}
printarray[VAR[0,0](arr), VAR[0,3](len)]
qsort[VAR[0,0](arr), 0, VAR[0,3](len) - 1]
printarray[VAR[0,0](arr), VAR[0,3](len)]
inter.Set(VAR[0,1](i),0)
Decl[string] test=i am a test value
Decl[char[]] c_str
Decl[int[][]] a
Decl[int[][]] b
Decl[int[][]] c
for(VAR[0,1](i)
;inter.IntRel;++ VAR[0,1](i)
){
PushStack
Decl[int] j=0
for(VAR[1,1](i)
;inter.IntRel;++ VAR[0,0](j)
){
inter.Set(VAR[1,6]([]),VAR[1,1](i))
inter.Set(VAR[1,7]([]),VAR[0,0](j))

}
RecoverStack

}
inter.Set(VAR[0,8](c),mult[VAR[0,6](a), VAR[0,7](b)])
for(inter.Set(VAR[0,1](i),0)
;inter.IntRel;++ VAR[0,1](i)
){
PushStack
Decl[int] j=0
print[[]
for(VAR[1,1](i)
;inter.IntRel;++ VAR[0,0](j)
){
print[ ]
print[inter.StrConversion(VAR[1,8]([]))]

}
print[ ]
]
RecoverStack

}
for(inter.Set(VAR[0,1](i),0)
;inter.IntRel;++ VAR[0,1](i)
){
inter.Set(VAR[0,5]([]),VAR[0,4]([]))

}
inter.Set(VAR[0,5]([]),0)
Decl[string[][]] nums
print[toString[VAR[0,5](c_str)]]
print[
]
for(inter.Set(VAR[0,1](i),0)
;inter.IntRel;++ VAR[0,1](i)
){
PushStack
for(Decl[int] j=0
;inter.IntRel;++ VAR[0,0](j)
){
inter.Set(VAR[1,9]([]),inter.StrConversion(VAR[1,1](i)) + , + inter.StrConversion(VAR[0,0](j)))

}
RecoverStack

}
for(inter.Set(VAR[0,1](i),0)
;inter.IntRel;++ VAR[0,1](i)
){
PushStack
Decl[int] j=0
for(VAR[1,1](i)
;inter.IntRel;++ VAR[0,0](j)
){
print[( + VAR[1,9]([]) + )]

}
print[
]
RecoverStack

}
print[
]
RecoverStack
println[inter.StrConversion(string2int[2556478])]
print[ + inter.StrConversion(sqrt[inter.IntRealConversion(3)]) + 
]
PushStack
Decl[string] a=    32145547852248562244    
print[quicksort(" + VAR[0,0](a) + ") = " + quicksort[VAR[0,0](a)] + "
]
print[trim( " + VAR[0,0](a) + ") = " + trim[VAR[0,0](a)] + "
]
RecoverStack
print[-----------------
]
print[+   Test End    +
]
print[-----------------
]
